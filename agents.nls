buses-own [
  ;Static read-only variables. These values never change. You can read them but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small" 2 means "medium" and 3 means "large".
    
  ;Dynamic read-only variables. These values may change over time. You can read them but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).
  
  ;New local variables for students.
  ;You can create any new local variable you want. Just declare them here.
  cur_pos
  own_schedule
  list-bus-stops
  busschedule
  returning
  transfers
  init
  init_pos
  init_schedule  
  bus_configuration
  ;line_passengers
  votes_for
  votes_responses
  request-timeout
  master_bus_id
  creation_count
  pos_trans
]
 
globals [
  graph
  amount_passengers_dropped
  amount_created_buses
]


;INIT FUNCTIONS
to init-buses
  ; Initialize your agents here.
  set master_bus_id 24
  set request-timeout 0
  init-busschedule
  
  ; This list contains the topology of the entire network of bus stops which is known to all agents. You can use this for instance to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]  

  ifelse bus_id != master_bus_id[
    send-message master_bus_id (list "request" "init")
  ][
    init-master-bus
  ]
end

to init-busschedule
  set busschedule [[16 5 17 7 1 23] [16 3 9 20 12] [2 8 9 3 9 8 6] [0 15 18 15 12] [11 1 19 23 14 0] [3 4 10 21 22 0] [3 4 10 13 23]]
end

to init-travel-start
  ;are we driving or starting to drive?
  ifelse current_stop = -1 or current_stop = 3[
    travel-to item init_pos init_schedule
  ][
    ;check if we arrived
    ifelse member? current_stop own_schedule[
      ;we made it
      set init false
    ][
      ;go to the next stop
      set init_pos init_pos + 1
      travel-to item init_pos init_schedule
    ]
  ] 
end



;MASTER
to execute-master
  let limit 8
  if count buses != limit[
    set limit limit - count buses
    repeat limit [
      add-bus 3
    ]
  ]
  check_mailbox_master
end

to check_mailbox_master
    ;go through inbox
    set creation_count 0
    foreach inbox[
      let mess ?1
      let _sender item 1 mess
      let message item 2 mess
      let _type item 0 message
      ifelse _type = "request"[
        handle-request-master _sender message
      ][
        handle-response-master _sender message
      ]
    ]
    set inbox []
end

to handle-request-master [_sender message]
  let _subject item 1 message 
  ifelse _subject = "init" [
    let bus_group get-bus-group _sender
    let bus_group_pos position bus_group bus_configuration
    send-message _sender (list "response" "init" bus_group_pos)
  ][
  let bus_group get-bus-group _sender
  
  ;schedule_pos gives the position of the schedule in the busschedule list
  let schedule_pos position bus_group bus_configuration
  
  if _subject = "vote"[
    ;sender wants to vote on whether to get an extra bus on its line
    ;request vote from all other buses on line and store
    ;also base own vote on amount passengers waiting at busstops
    
    ;a request to vote counts as a vote for
    set votes_for replace-item schedule_pos votes_for 1
    set votes_responses replace-item schedule_pos votes_responses 1
    
    ifelse length bus_group = 1[
      ;if only 1 bus, we already have the amount of votes for and are done!
      evaluate-line schedule_pos
      set votes_for replace-item schedule_pos votes_for 0
      set votes_responses replace-item schedule_pos votes_responses 0
    ][
    ;else ask for vote from other busses
    if item schedule_pos votes_for = 1 [
      foreach bus_group[
        if _sender != ?1[
          send-message ?1 (list "request" "vote")
        ]
      ]
    ]
    ]
  ]
  if _subject = "bidding" [
    let bus_stop item 2 message
    ;check eerst of andere lijnen ook deze stop in hun schedule hebben
    let competition []
    foreach bus_group[
      if _sender != ?1 and member? bus_stop ?1 [
        set competition lput ?1 competition
      ]
    ]
    
    ifelse length bus_group = 1 and competition = [][
      ;Bus is alone, automatically wins bidding
      send-message _sender (list "response" "bidding")
      ;Doen dacht ik alleen een response als je wint, scheelt messages. Moet nog wel verwerken in andere bussen dat ze 2 ticks wachten en anders verlies rekenen.
    ][
    ;Vraag alle deelnemende bussen om hun bod
    ;Process die bij handle-response-master
    foreach competition[
      send-message ?1 (list "request" "bid" bus_stop)
    ]
    ]
  ]
  ]
end

to handle-response-master [_sender message]
  let _subject item 1 message

  if _subject = "vote" [
    let bus_group get-bus-group _sender
    let schedule_pos position bus_group bus_configuration
    
    let vote item 2 message
    let amount_for item schedule_pos votes_for
    set amount_for amount_for + vote
    set votes_for replace-item schedule_pos votes_for amount_for
    
    let vote_responses item schedule_pos votes_responses
    set vote_responses vote_responses + 1
    set votes_responses replace-item schedule_pos votes_responses vote_responses 
    
    if vote_responses = length bus_group [
      evaluate-line schedule_pos
      set votes_for replace-item schedule_pos votes_for 0
      set votes_responses replace-item schedule_pos votes_responses 0
    ]
  ]
end

to evaluate-line [schedule_pos]
  ;check if votes for have majority
  let possible_votes (length item schedule_pos bus_configuration)
  let amount_for item schedule_pos votes_for
  if amount_for > floor (possible_votes / 2) [
    add-bus-line schedule_pos
    set amount_created_buses amount_created_buses + 1
  ]
end

to-report get-bus-group [_sender]
  ;bus_group gives the group of busses which operate on the same line
  let bus_group 0
  foreach bus_configuration[
    if member? _sender ?1[
      set bus_group ?1
    ]
  ]
  report bus_group
end

to add-bus-line [schedule_pos]
  ;get newest id
  let new_id who + count buses + creation_count
  set creation_count creation_count + 1
  ;add new bus to bus_configuration
  set bus_configuration replace-item schedule_pos bus_configuration lput new_id item schedule_pos bus_configuration
  add-bus 3
end

to-report get-capacity [_bus_type]
  let capacity 0
  if _bus_type = 1 [set capacity bus_type1_capacity]
  if _bus_type = 2 [set capacity bus_type2_capacity]
  if _bus_type = 3 [set capacity bus_type3_capacity]
  report capacity
end

to-report get-space
  report get-capacity bus_type - length bus_passengers
end

to-report check-busstops [schedule_pos]
  let schedule item schedule_pos busschedule
  let total 0
  foreach schedule[
    set total total + length get-passengers-at-stop ?1
  ]
  report total
end



;ALL BUSES
to check_inbox
  foreach inbox[
    let mess ?1
    let _sender item 1 mess
    let message item 2 mess
    let _type item 0 message
    if _type = "request"[
      handle-request _sender message
    ]
    if _type = "response"[
      handle-response _sender message
    ]
  ]
  set inbox []
end

to handle-request [_sender message]
  let _subject item 1 message

  if _subject = "vote" [
    let capacity get-capacity bus_type
    ifelse length bus_passengers > .67 * capacity [
      send-message _sender (list "response" "vote" 1)
    ][
      send-message _sender (list "response" "vote" 0)
    ]
  ]
end

to handle-response [_sender message]
  let _subject item 1 message
  if _subject = "init" [
    let pos item 2 message
    ifelse pos = 0[
      init-line-15
    ][
    ifelse pos = 1[
      init-line-22
    ][
    ifelse pos = 2[
      init-line-34
    ][
    ifelse pos = 3[
      init-line-40
    ][
    ifelse pos = 4[
      init-line-62
    ][
    ifelse pos = 5[
      init-line-42
    ][
    init-line-45
    ]]]]]]
  ]
  if _subject = "bidding" [
    
  ]
end

to kick-passengers-out
  foreach bus_passengers [
    let pass_id item 0 ?1
    let des item 1 ?1
    
    let trans_des -2
    let trans_des_pos -2
    let trans_id_pos -2    
   
    ;Heeft deze passagier een transfer?
    if is-number? (position pass_id transfers) [
      set trans_id_pos (position pass_id transfers)
      set trans_des_pos (trans_id_pos + 1)
      set trans_des (item trans_des_pos transfers)
    ]
       
    if des = current_stop or trans_des = current_stop[
      ;uitstappen en transfers of aantal passengers dropped aanpassen
      drop-off-passenger pass_id
      ifelse trans_des = -2 [
        set amount_passengers_dropped amount_passengers_dropped + 1
      ][
        set transfers remove-item (trans_des_pos) transfers
        set transfers remove-item (trans_id_pos) transfers
      ]
    ]
  ]
end

to-report get-passenger-one-transfer [pass_id des]
  set pos_trans []
  foreach busschedule [
    let other_schedule 0
    if ?1 != own_schedule [set other_schedule ?1]  ; don't compare with itself
    let transfer 0
    if is-list? other_schedule [
      foreach other_schedule [
        if member? ?1 own_schedule [
          ;transfer possible
          set transfer ?1
          set pos_trans lput transfer pos_trans
          ;check if this works in 1 go
          if member? des other_schedule [
            ifelse transfer = current_stop[
              ;this is the transfer location; don't pick up passenger
              report true
            ][
              set transfers lput pass_id transfers
              set transfers lput transfer transfers
              pick-up-passenger pass_id
              report true
            ]
          ]
        ]
      ]
    ]
  ]
  report false
end

to-report get-passenger-two-transfers [pass_id des]
  let transfer 0
  foreach pos_trans[
    ;search schema from this site
    set transfer ?1
    foreach busschedule [
      let other_schedule 0
      if ?1 != own_schedule [set other_schedule ?1]
      if is-list? other_schedule and member? transfer other_schedule [
        ;zo een schema gevonden, hier kun je niet in 1x door (al eerder gevonden).
        ;kan je er nu wel in 1x komen? (verbetering?)
        let second_trans 0
        foreach other_schedule[
          set second_trans ?1
          foreach busschedule[
            if member? second_trans ?1 and member? des ?1 [
              ;this is an improvement!
              ifelse transfer = current_stop[
                ;this is the transfer location; don't pick up passenger
                report true
              ][
                set transfers lput pass_id transfers
                set transfers lput transfer transfers
                pick-up-passenger pass_id
                report true
              ]
            ]
          ]
        ]
      ]              
    ]
  ]
  report false
end

to get-new-passenger [pass_id des]
  ; check if bussize is big enough to fit another passenger
  if (length bus_passengers) >= get-capacity bus_type[
    stop
  ]

  ;des(tination) is in own_schedule?
  if member? des own_schedule [
    pick-up-passenger pass_id
    stop
  ]

  ;other lines pass this bus-stop and have destination?
  foreach busschedule [
    let other_schedule ?1
    if (member? des other_schedule and member? current_stop other_schedule)[
      ;wait for other bus.
      stop
    ]
  ]

  ;transfer!
  ;check if other lines have connections with current line, so transfer possible
  if get-passenger-one-transfer pass_id des [
    stop
  ]

  ;TODO: check if another bus can pick it up with one transfer
  
  ;double transfer! (is always possible in our schedule)
  if get-passenger-two-transfers pass_id des [
    stop
  ]
end

to get-new-passengers
  let found false
  foreach get-passengers-at-stop current_stop[
    let pass_id item 0 ?1
    let des item 1 ?1
    get-new-passenger pass_id des
  ]
end

to execute-actions
  ;bus_24 makes more buses and then stops
  if bus_id = master_bus_id[
    execute-master
    stop
  ]
  
  if own_schedule = 0 [
    ;nog niet geïnitieerd
    check_inbox
    stop
  ]
  
  if init = true[
    init-travel-start
    check_inbox
    if init = true[
      stop
    ]
  ]
  
  ; Add decision making strategies for your agents here.
  ; You are allowed to use the global variable 'ticks'
  ifelse current_stop = -1 [
    ;driving
    travel-to next_stop
  ][
    ;arrived at busstop
    ;KICK PASSENGERS OUT
    kick-passengers-out

    ;GET NEW PASSENGERS IN
    get-new-passengers

    ;Returning or not?
    ifelse returning[
      set cur_pos cur_pos - 1
    ][
      set cur_pos cur_pos + 1 
    ]
    if cur_pos > (length own_schedule) - 1[
      set returning true
      set cur_pos cur_pos - 2
    ]
    if cur_pos < 0 [
      set returning false
      set cur_pos 1
    ]
    
    ;Are we almost full?
    let capacity get-capacity bus_type
    if length bus_passengers > .67 * capacity and request-timeout = 0 [
      ;we are 2/3 full, send message about possible new bus
      
      ;let _space get-space
      
      ;send-message master_bus_id (list "request" "investigate" _space)
      send-message master_bus_id (list "request" "vote")
      
      set request-timeout 15
    ]
    if request-timeout > 0 [
      set request-timeout request-timeout - 1
    ]
    
    ;start moving 
    let next_bus_stop item cur_pos own_schedule
    travel-to next_bus_stop
   
    ;check if bidding is needed
    foreach busschedule[
      if member? next_bus_stop ?1 [
        send-message master_bus_id (list "request" "bidding" next_bus_stop)
        stop
      ]
    ]
  ]
  
  check_inbox
end



;INIT BUSES
to init-master-bus
  set creation_count 0
  set bus_configuration [[25] [26] [27] [28] [29] [30] [31]]
  ;set line_passengers [[0 0] [0 0] [0 0] [0 0] [0 0] [0 0] [0 0]]
  set votes_for [0 0 0 0 0 0 0]
  set votes_responses [0 0 0 0 0 0 0]
end

to init-line-15
  set transfers []
  set init true
  set init_pos 0
  set init_schedule [16]
  set own_schedule item 0 busschedule
  set returning false
end

to init-line-22
  set transfers []
  set init false
  set cur_pos 1
  set own_schedule item 1 busschedule
  set returning false
end

to init-line-34
  set transfers []
  set init false
  set cur_pos 3
  set own_schedule item 2 busschedule
  set returning false
end

to init-line-40
  set transfers []
  set init true
  set init_schedule [9 20 12]
  set own_schedule item 3 busschedule
  set returning false
end

to init-line-62
  set transfers []
  set init true
  set init_pos 0
  set init_schedule [4 10 21 22 0]
  set cur_pos 5
  set own_schedule item 4 busschedule
  set returning true
end

to init-line-42
  set transfers []
  set init false
  set cur_pos 0
  set own_schedule item 5 busschedule
  set returning false
end

to init-line-45
  set transfers []
  set init false
  set cur_pos 0
  set own_schedule item 6 busschedule
  set returning false
end